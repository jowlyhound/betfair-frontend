<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>üèá Betfair Racing Tracker - Live</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'><text y='18' font-size='18'>üèá</text></svg>" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      background: linear-gradient(135deg, #1e3c72, #2a5298);
      color: white; min-height: 100vh; padding: 15px;
    }
    .header { text-align: center; padding: 20px; background: rgba(0,0,0,0.3); 
      border-radius: 20px; margin-bottom: 20px; backdrop-filter: blur(10px); }
    .live-badge { background: #FF5722; padding: 4px 8px; border-radius: 10px; 
      font-size: 11px; font-weight: bold; animation: pulse 2s infinite; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
    .stats { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin: 15px 0; }
    .stat { text-align: center; padding: 15px; background: rgba(255,255,255,0.15); 
      border-radius: 15px; backdrop-filter: blur(10px); }
    .stat-value { font-size: 22px; font-weight: bold; color: #FFD700; }
    .stat-label { font-size: 10px; opacity: 0.8; text-transform: uppercase; margin-top: 5px; }
    .controls { background: rgba(255,255,255,0.1); padding: 15px; border-radius: 15px; 
      margin-bottom: 20px; backdrop-filter: blur(10px); text-align: center; }
    .start-btn { padding: 15px 30px; background: linear-gradient(135deg, #4CAF50, #45a049);
      border: none; border-radius: 15px; color: white; font-size: 16px; font-weight: bold;
      cursor: pointer; margin: 10px; transition: all 0.3s; }
    .start-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 20px rgba(76,175,80,0.4); }
    .start-btn.active { background: linear-gradient(135deg, #FF6B6B, #FF8E53); animation: glow 2s infinite; }
    .start-btn.scanning { background: linear-gradient(135deg, #FF6B6B, #FF8E53); animation: glow 2s infinite; }
    @keyframes glow { 0%, 100% { box-shadow: 0 4px 20px rgba(255,107,107,0.4); } 50% { box-shadow: 0 4px 30px rgba(255,107,107,0.6); } }
    .market-card { background: rgba(255,255,255,0.1); padding: 15px; border-radius: 15px; 
      margin: 15px 0; backdrop-filter: blur(10px); }
    .market-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
    .market-name { font-weight: bold; font-size: 18px; }
    .market-info { font-size: 12px; opacity: 0.8; }
    .market-list { margin-top: 10px; }
    .market-item { background: rgba(255,255,255,0.1); padding: 12px; border-radius: 10px; 
      margin: 8px 0; display: flex; justify-content: space-between; align-items: center;
      cursor: pointer; transition: all 0.2s; }
    .market-item:hover { background: rgba(255,255,255,0.2); transform: translateY(-1px); }
    .market-item.analyzing { background: linear-gradient(45deg, rgba(76,175,80,0.3), rgba(76,175,80,0.1)); 
      animation: analyze 1s infinite; }
    @keyframes analyze { 0%, 100% { transform: translateX(0); } 50% { transform: translateX(2px); } }
    .market-time { font-weight: bold; color: #FFD700; }
    .market-name-text { flex: 1; margin: 0 10px; font-size: 14px; }
    .runner-count { background: rgba(255,255,255,0.2); padding: 4px 8px; border-radius: 8px; 
      font-size: 12px; }
    .pattern-alerts { margin-top: 20px; }
    .signal-item { background: rgba(255,255,255,0.15); margin: 10px 0; padding: 15px; 
      border-radius: 15px; backdrop-filter: blur(15px); border-left: 4px solid #4CAF50;
      animation: slideIn 0.3s ease; }
    @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
    .signal-item.signal-steam { border-left-color: #f39c12; }
    .signal-item.signal-smart { border-left-color: #3498db; }
    .signal-item.signal-confidence { border-left-color: #2ecc71; }
    .signal-item.signal-whale { border-left-color: #e74c3c; }
    .signal-item.signal-late { border-left-color: #FF6B6B; }
    .signal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
    .signal-conf { background: rgba(255,255,255,0.3); padding: 4px 10px; border-radius: 12px; 
      font-size: 12px; font-weight: bold; }
    .signal-type { display: inline-block; background: rgba(255,255,255,0.25); padding: 3px 8px; 
      border-radius: 10px; font-size: 10px; margin: 2px; text-transform: uppercase; }
    .signal-desc { font-size: 13px; margin-bottom: 4px; }
    .signal-meta { font-size: 11px; opacity: 0.7; }
    .status { background: rgba(76,175,80,0.2); border: 1px solid rgba(76,175,80,0.5); 
      padding: 12px; border-radius: 10px; margin: 10px 0; font-size: 14px; text-align: center; }
    .status.warning { background: rgba(255,193,7,0.2); border-color: rgba(255,193,7,0.5); }
    .status.info { background: rgba(33,150,243,0.2); border-color: rgba(33,150,243,0.5); }
    input, select { background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.2); 
      border-radius: 8px; padding: 8px 10px; font-size: 13px; }
    input::placeholder { color: rgba(255,255,255,0.5); }
    .flex { display:flex; gap:8px; align-items:center; }
    .grow { flex:1; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; }
    .btn { padding: 8px 15px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); 
      border-radius: 8px; color: white; cursor: pointer; font-size: 13px; transition: all 0.2s; }
    .btn:hover { background: rgba(255,255,255,0.2); }
    table { width: 100%; border-collapse: collapse; background: rgba(255,255,255,0.05); border-radius: 10px; overflow: hidden; }
    th, td { padding: 8px 10px; border-bottom: 1px solid rgba(255,255,255,0.1); font-size: 13px; }
    th { text-align: left; background: rgba(255,255,255,0.1); font-weight: bold; }
    .price { font-variant-numeric: tabular-nums; }
    .muted { opacity: 0.7; }
  </style>
</head>
<body>
  <div class="header">
    <h1>üèá Betfair Racing Tracker</h1>
    <div style="margin-top: 10px; font-size: 14px;">
      <span class="live-badge">LIVE</span>
      <span style="margin-left: 10px;" id="connection-status">Connected</span>
    </div>
  </div>

  <div class="stats">
    <div class="stat">
      <div class="stat-value" id="totalMarkets">0</div>
      <div class="stat-label">Markets</div>
    </div>
    <div class="stat">
      <div class="stat-value" id="totalRunners">0</div>
      <div class="stat-label">Runners</div>
    </div>
    <div class="stat">
      <div class="stat-value" id="patternsFound">0</div>
      <div class="stat-label">Patterns</div>
    </div>
    <div class="stat">
      <div class="stat-value" id="frameCount">0</div>
      <div class="stat-label">Data Frames</div>
    </div>
  </div>

  <div class="controls">
    <div style="margin-bottom: 15px;">
      üîç <strong>Live Pattern Detection</strong> - Scanning Betfair exchange for betting opportunities
    </div>
    <button class="start-btn" id="scanButton">üöÄ Start Pattern Scanning</button>
    <button class="start-btn" id="btn-refresh">üîÑ Refresh Market Data</button>
  </div>

  <div class="status" id="status">üì° Connecting to Betfair stream...</div>

  <div class="market-card">
    <div class="market-header">
      <div class="market-name">üèÅ Available Markets</div>
      <div class="market-info">
        <input id="search" class="grow" placeholder="Search course or off-time (e.g. 'Wolv' or '14:10')" style="width: 300px;" />
      </div>
    </div>
    <div class="market-list" id="market-list" role="listbox" aria-label="Markets"></div>
  </div>

  <div class="market-card">
    <div class="market-header">
      <div class="market-name" id="market-title">Select a market‚Ä¶</div>
      <div class="market-info">
        <div class="flex">
          <select id="sort">
            <option value="fav">By price (fav first)</option>
            <option value="alpha">By runner name (A‚ÜíZ)</option>
            <option value="num">By runner #</option>
          </select>
          <select id="cols" style="margin-left: 10px;">
            <option value="best">Best Back/Lay</option>
            <option value="ltp">Last Traded Price</option>
            <option value="both">Both</option>
          </select>
        </div>
      </div>
    </div>
    <div style="padding: 10px;">
      <table>
        <thead>
          <tr id="thead-row"></tr>
        </thead>
        <tbody id="runner-body"></tbody>
      </table>
    </div>
    <div style="padding: 10px;">
      <details>
        <summary class="muted">Debug</summary>
        <pre class="mono" id="debug" style="max-height:160px; overflow:auto;"></pre>
      </details>
    </div>
  </div>

  <div id="patternAlerts" class="pattern-alerts"></div>

  <div class="wrap" style="display: none;">
    <div class="grid">
      <!-- Markets list -->
      <section class="card">
        <h3>Markets</h3>
        <div class="controls">
          <input id="search" class="grow" placeholder="Search course or off-time (e.g. 'Wolv' or '14:10')" />
          <button class="btn" id="btn-refresh">Refresh</button>
        </div>
        <div class="list" id="market-list" role="listbox" aria-label="Markets"></div>
      </section>

      <!-- Signals Panel -->
      <section class="card" id="signals-panel" style="display:none;">
        <h3>üö® Live Signals</h3>
        <div style="padding:12px; max-height:400px; overflow-y:auto;" id="signals-list">
          <!-- Signals will appear here -->
        </div>
      </section>

      <!-- Market details -->
      <section class="card">
        <h3 id="market-title">Select a market‚Ä¶</h3>
        <div class="controls">
          <div class="flex">
            <label class="muted">Sort:</label>
            <select id="sort">
              <option value="fav">By price (fav first)</option>
              <option value="alpha">By runner name (A‚ÜíZ)</option>
              <option value="num">By runner #</option>
            </select>
          </div>
          <div class="flex">
            <label class="muted">Columns:</label>
            <select id="cols">
              <option value="best">Best Back/Lay</option>
              <option value="ltp">Last Traded Price</option>
              <option value="both">Both</option>
            </select>
          </div>
        </div>
        <div style="padding:10px 12px;">
          <table>
            <thead>
              <tr id="thead-row"></tr>
            </thead>
            <tbody id="runner-body"></tbody>
          </table>
        </div>
        <div style="padding:10px 12px;">
          <details>
            <summary class="muted">Debug</summary>
            <pre class="mono" id="debug" style="max-height:160px; overflow:auto;"></pre>
          </details>
        </div>
      </section>
    </div>
  </div>

  <script>
    /*** --- CONFIG --- ***/
    const WS_URL = "wss://betfair-c44j.onrender.com";
    const REQUIRE_SUBSCRIBE = true;          // force a subscribe from the client
    const MAX_MARKETS_TO_TRACK = 1;          // track the next-off market

    /*** --- LIGHT STORE --- ***/
    class BetfairStore {
      constructor(){ this.markets=new Map(); this.listeners=new Set(); }
      onSignal(fn){ this.listeners.add(fn); return ()=>this.listeners.delete(fn); }
      emit(sig){ for(const fn of this.listeners) fn(sig); }
      mkt(id){ if(!this.markets.has(id)) this.markets.set(id,{id,venue:'',name:'',startTime:null,runners:new Map()}); return this.markets.get(id); }
      run(m, selId){
        const r=m.runners.get(selId)||{id:selId,name:`#${selId}`,sort:999,hist:[],depth:[],lastSignalAt:0};
        m.runners.set(selId,r); return r;
      }
      upsert(mc){
        const id=mc.id||mc.marketId; if(!id) return;
        const m=this.mkt(id);
        if(mc.marketDefinition){
          const md=mc.marketDefinition;
          m.name=md.name||m.name; m.venue=md.venue||m.venue; m.startTime=md.marketTime||m.startTime;
          (md.runners||[]).forEach(rr=>{ const r=this.run(m, rr.id); r.name=rr.name||r.name; r.sort=rr.sortPriority??r.sort; });
        }
        const now=Date.now();
        (mc.rc||[]).forEach(rc=>{
          const r=this.run(m, rc.id);
          if(rc.ltp!=null){
            r.hist.push({t:now, ltp: rc.ltp});
            const cut=now-5*60*1000; while(r.hist.length && r.hist[0].t<cut) r.hist.shift();
          }
          let bb = r.depth.length? r.depth[r.depth.length-1].bbSize : 0;
          let bl = r.depth.length? r.depth[r.depth.length-1].blSize : 0;
          if(Array.isArray(rc.atb) && rc.atb[0]) bb = rc.atb[0][1];
          if(Array.isArray(rc.atl) && rc.atl[0]) bl = rc.atl[0][1];
          r.depth.push({t:now, bbSize:bb, blSize:bl});
          const cut2=now-5*60*1000; while(r.depth.length && r.depth[0].t<cut2) r.depth.shift();

          if(now - r.lastSignalAt > 8000){
            const sig = detectSignals(m, r);
            if(sig){ r.lastSignalAt=now; this.emit(sig); }
          }
        });
      }
    }

    /*** --- ENHANCED DETECTORS --- ***/
    function detectSignals(mkt, r){
      const now=Date.now();
      
      // 1. STEAM MOVE: Sharp price drop (smart money entering)
      const rec3m=r.hist.filter(h=> h.t>=now-180000);
      if(rec3m.length>=3){
        const start=rec3m[0].ltp, end=rec3m[rec3m.length-1].ltp;
        const mid = rec3m[Math.floor(rec3m.length/2)].ltp;
        if(start && end && mid && end<=start*0.85){
          // Check if drop was consistent (not just a single spike)
          const consistency = (start-end) / (start-mid + mid-end) * 2;
          if(consistency > 0.7) {
            return sig('STEAM_MOVE', r.name, mkt, 0.8, `Consistent price drop ${Math.round((1-end/start)*100)}% in 3m`);
          }
        }
      }

      // 2. SMART MONEY ENTRY: Large single back matched at good price
      const rec30s=r.hist.filter(h=> h.t>=now-30000);
      if(rec30s.length>=2){
        const recent = rec30s.slice(-2);
        const priceImprovement = (recent[0].ltp - recent[1].ltp) / recent[0].ltp;
        if(priceImprovement > 0.05) { // 5% improvement
          return sig('SMART_MONEY', r.name, mkt, 0.75, `Large back matched - price improved ${(priceImprovement*100).toFixed(1)}%`);
        }
      }

      // 3. MARKET CONFIDENCE: Sustained backing with volume
      const dep60s=r.depth.filter(d=> d.t>=now-60000);
      if(dep60s.length>=3){
        const backTrend = dep60s.slice(-3).every((d,i,arr) => i===0 || d.bbSize >= arr[i-1].bbSize);
        const avgBack = dep60s.reduce((s,d)=>s+d.bbSize,0) / dep60s.length;
        if(backTrend && avgBack > 100) {
          return sig('MARKET_CONFIDENCE', r.name, mkt, 0.7, `Sustained backing trend - avg size ${avgBack.toFixed(0)}`);
        }
      }

      // 4. WHALE ACTIVITY: Massive single-side volume
      const dep10s=r.depth.filter(d=> d.t>=now-10000);
      if(dep10s.length){
        const last=dep10s[dep10s.length-1];
        const ratio=(last.bbSize||0.0001)/(last.blSize||0.0001);
        const totalVol = (last.bbSize||0) + (last.blSize||0);
        if(ratio>=4 && totalVol>500) {
          return sig('WHALE_ACTIVITY', r.name, mkt, 0.85, `Massive backing - ${ratio.toFixed(1)}√ó lay, ¬£${totalVol.toFixed(0)} volume`);
        }
      }

      // 5. LATE STEAM: Strong move close to race time (if we have race time)
      if(mkt.startTime){
        const raceTime = new Date(mkt.startTime).getTime();
        const minsToRace = (raceTime - now) / (1000 * 60);
        if(minsToRace > 0 && minsToRace < 10 && rec3m.length>=2){
          const start=rec3m[0].ltp, end=rec3m[rec3m.length-1].ltp;
          if(start && end && end<=start*0.9){
            const urgency = Math.max(0.6, 1 - (minsToRace/10));
            return sig('LATE_STEAM', r.name, mkt, urgency, `Late steam ${Math.round((1-end/start)*100)}% - ${minsToRace.toFixed(1)}m to race`);
          }
        }
      }

      return null;
    }
    function sig(type, name, mkt, conf, desc){
      const t = mkt.startTime? new Date(mkt.startTime):null;
      const hhmm = t? t.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}) : '‚Äî';
      return { type, name, track: mkt.venue||'GB/IE', confidence: conf, description: desc, race: `${mkt.venue||'Course'} ${hhmm}` };
    }

    /*** --- WS CLIENT (very defensive) --- ***/
    let ws, hbTimer, reconnectTimer, backoff=1000, firstSubscribeSent=false, framesSeen=0, firstFrame=null;
    const store = new BetfairStore();

    function wsConnect(){
      setConn('Connecting‚Ä¶');
      try { ws = new WebSocket(WS_URL); } catch(e){ setConn('WS error'); console.error(e); return; }

      ws.onopen = () => {
        setConn('Connected');
        backoff=1000;
        wsSend({type:'hello', client:'mobile-tracker', ts:Date.now()});
        startHB();
      };

      ws.onmessage = (evt) => {
        framesSeen++;
        const payloads = normalizeFrames(evt.data);
        for(const p of payloads){
          const msg = safeParse(p);
          if(!msg) continue;

          if(!firstFrame){ firstFrame = msg; console.debug('[WS:first]', msg); }

          const mcArr = extractMarketChanges(msg);
          if(mcArr && mcArr.length){
            console.debug(`[WS] Processing ${mcArr.length} market changes`);
            mcArr.forEach(mc => store.upsert(mc));
            if(REQUIRE_SUBSCRIBE) maybeAutoSubscribe();
            console.debug(`[WS] Store now has ${store.markets.size} markets`);
          }

          const statusMsg = extractStatus(msg);
          if(statusMsg){ setConn(statusMsg); }
        }
        // simple heartbeat UI
        const el = document.getElementById('lastUpdate');
        if(el) el.textContent = new Date().toLocaleTimeString();
        
        // Update stats display
        const frameCount = document.getElementById('frameCount');
        const totalMarkets = document.getElementById('totalMarkets');
        const totalRunners = document.getElementById('totalRunners');
        
        if(frameCount) frameCount.textContent = framesSeen;
        if(totalMarkets) totalMarkets.textContent = store.markets.size;
        if(totalRunners) {
          let runnerCount = 0;
          store.markets.forEach(m => runnerCount += m.runners.size);
          totalRunners.textContent = runnerCount;
        }
      };

      ws.onclose = () => { setConn('Disconnected'); stopHB(); scheduleReconnect(); };
      ws.onerror = (e) => { console.warn('WS error', e); };
    }

    function normalizeFrames(data){
      // Handle: raw JSON, NDJSON, arrays, strings with logs
      if(typeof data === 'string'){
        // sometimes servers send multiple JSON lines
        return data.split('\n').filter(Boolean);
      }
      return [data];
    }
    function safeParse(s){ try{ return typeof s==='string' ? JSON.parse(s) : s; } catch{ return null; } }
    function wsSend(obj){ if(ws && ws.readyState===1) ws.send(JSON.stringify(obj)); }
    function startHB(){ stopHB(); hbTimer=setInterval(()=>wsSend({type:'ping',ts:Date.now()}), 20000); }
    function stopHB(){ clearInterval(hbTimer); }
    function scheduleReconnect(){ clearTimeout(reconnectTimer); reconnectTimer=setTimeout(wsConnect, backoff); backoff=Math.min(backoff*1.7,15000); }

    function extractMarketChanges(msg){
      // unwrap common proxy envelopes: {op:'mcm', mc:[...]}, {mc:[...]}, {data:{...}}, {payload:{...}}, {mcm:{mc:[...]}}
      let cur = msg;
      for(let i=0;i<3;i++){
        if(cur && cur.data) cur = cur.data; else if(cur && cur.payload) cur = cur.payload; else break;
      }
      if(cur && cur.mcm && Array.isArray(cur.mcm.mc)) return cur.mcm.mc;
      if(cur && cur.op==='mcm' && Array.isArray(cur.mc)) return cur.mc;
      if(cur && Array.isArray(cur.mc)) return cur.mc;
      return null;
    }
    function extractStatus(msg){
      const t = (msg && (msg.type||msg.level)) || '';
      if(t==='status' || t==='info' || t==='error'){ return msg.message || t; }
      return null;
    }

    function maybeAutoSubscribe(){
      if(firstSubscribeSent) return;
      // Choose earliest upcoming market we've seen definitions for
      const withTime = Array.from(store.markets.values()).filter(m=>m.startTime);
      if(!withTime.length) return;
      const ids = withTime.sort((a,b)=>+new Date(a.startTime) - +new Date(b.startTime))
                          .slice(0, MAX_MARKETS_TO_TRACK).map(m=>m.id);
      if(!ids.length) return;
      wsSend({
        op: "marketSubscription",
        id: 1,
        marketFilter: { marketIds: ids },
        priceProjection: { priceData: ["EX_BEST_OFFERS", "EX_LTP"] }
      });
      firstSubscribeSent = true;
      console.debug('[WS] Sent marketSubscription for', ids);
    }

    function setConn(text){
      const pulse=document.getElementById('connectionPulse');
      const txt=document.getElementById('status');
      const connStatus=document.getElementById('connection-status');
      
      if(txt) {
        if(text.includes('Connected') || text.includes('Live')) {
          txt.textContent = '‚úÖ Live data stream active';
          txt.className = 'status';
        } else if(text.includes('Connecting')) {
          txt.textContent = 'üì° Connecting to Betfair stream...';
          txt.className = 'status info';
        } else {
          txt.textContent = '‚ùå ' + text;
          txt.className = 'status warning';
        }
      }
      
      if(connStatus) connStatus.textContent = text;
      if(pulse) pulse.style.background = (text.includes('Connected')||text.includes('Live')) ? '#4CAF50' : '#FF7043';
    }

    // expose store for app
    window.__BF_STORE__ = store;
    window.__BF_WS_CONNECT__ = wsConnect;

    // =======================
    // STATE (legacy for UI compatibility)
    // =======================
    const state = {
      connected: false,
      markets: new Map(), // marketId -> {id, name, venue, startTime, runners: Map(selectionId -> runnerObj)}
      currentMarketId: null,
      lastMessage: null,
    };

    // On boot: restore last selected market
    try {
      const last = localStorage.getItem('lastMarketId');
      if (last) state.currentMarketId = last;
    } catch {}

    // =======================
    // UI COMPATIBILITY FUNCTIONS
    // =======================
    function renderMarketList() {
      const q = document.getElementById('search').value?.trim().toLowerCase();
      const list = document.getElementById('market-list');
      list.innerHTML = '';

      // Get markets from new store
      const store = window.__BF_STORE__;
      if (!store || !store.markets) {
        console.debug('[UI] Store not available yet');
        return;
      }
      
      const items = Array.from(store.markets.values()).sort((a, b) => {
        const ta = a.startTime ? +new Date(a.startTime) : Infinity;
        const tb = b.startTime ? +new Date(b.startTime) : Infinity;
        return ta - tb;
      });

      console.debug(`[UI] Rendering ${items.length} markets`);

      for (const m of items) {
        const title = [m.venue, m.name].filter(Boolean).join(' ¬∑ ');
        const time = m.startTime ? new Date(m.startTime) : null;
        const off = time ? time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '‚Äî';
        const runnerCount = m.runners ? m.runners.size : 0;

        // Filter
        if (q) {
          const hay = `${title} ${off}`.toLowerCase();
          if (!hay.includes(q)) continue;
        }

        const div = document.createElement('div');
        div.className = 'market-item';
        div.role = 'option';
        div.dataset.id = m.id;
        div.onclick = () => selectMarket(m.id, true);
        div.innerHTML = `
          <div class="market-time">${off}</div>
          <div class="market-name-text">${title || m.id}</div>
          <div class="runner-count">${runnerCount} runners</div>
        `;
        list.appendChild(div);
      }
    }

    function selectMarket(marketId, focus) {
      state.currentMarketId = marketId;
      try { localStorage.setItem('lastMarketId', marketId); } catch {}
      const m = window.__BF_STORE__.markets.get(marketId);
      if (!m) return;

      document.getElementById('market-title').textContent =
        [m.venue, m.name].filter(Boolean).join(' ¬∑ ') || marketId;

      renderTable(m);
    }

    function renderTable(market) {
      const colsMode = document.getElementById('cols').value; // best | ltp | both
      const sortMode = document.getElementById('sort').value; // fav | alpha | num

      // Build header
      const thead = document.getElementById('thead-row');
      thead.innerHTML = '';
      const h1 = document.createElement('th'); h1.textContent = '#'; thead.appendChild(h1);
      const h2 = document.createElement('th'); h2.textContent = 'Runner'; thead.appendChild(h2);

      if (colsMode === 'best' || colsMode === 'both') {
        const hb = document.createElement('th'); hb.textContent = 'Best Back'; thead.appendChild(hb);
        const hl = document.createElement('th'); hl.textContent = 'Best Lay'; thead.appendChild(hl);
      }
      if (colsMode === 'ltp' || colsMode === 'both') {
        const ht = document.createElement('th'); ht.textContent = 'LTP'; thead.appendChild(ht);
      }

      // Prepare runners - get current depth for display
      let runners = Array.from(market.runners.values()).map(r => {
        const latestDepth = r.depth && r.depth.length ? r.depth[r.depth.length-1] : {};
        const latestHist = r.hist && r.hist.length ? r.hist[r.hist.length-1] : {};
        return {
          ...r,
          bestBack: latestDepth.bbSize > 0 ? 'Size:' + latestDepth.bbSize : '‚Äî',
          bestLay: latestDepth.blSize > 0 ? 'Size:' + latestDepth.blSize : '‚Äî',
          ltp: latestHist.ltp || '‚Äî'
        };
      });

      if (sortMode === 'fav') {
        runners.sort((a, b) => (a.sort - b.sort) || (a.id - b.id));
      } else if (sortMode === 'alpha') {
        runners.sort((a, b) => (a.name || '').localeCompare(b.name || ''));
      } else {
        runners.sort((a, b) => (a.sort - b.sort) || (a.id - b.id));
      }

      // Body
      const tbody = document.getElementById('runner-body');
      tbody.innerHTML = '';

      for (const r of runners) {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td class="mono muted">${r.sort ?? ''}</td>
          <td>${escapeHtml(r.name || `#${r.id}`)}</td>
        `;
        if (colsMode === 'best' || colsMode === 'both') {
          tr.innerHTML += `
            <td class="price">${r.bestBack}</td>
            <td class="price">${r.bestLay}</td>
          `;
        }
        if (colsMode === 'ltp' || colsMode === 'both') {
          tr.innerHTML += `
            <td class="price">${r.ltp}</td>
          `;
        }
        tbody.appendChild(tr);
      }
    }

    function escapeHtml(s) { return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

    // =======================
    // UI HOOKS
    // =======================
    document.getElementById('search').addEventListener('input', renderMarketList);
    document.getElementById('cols').addEventListener('change', () => {
      if (state.currentMarketId) selectMarket(state.currentMarketId, false);
    });
    document.getElementById('sort').addEventListener('change', () => {
      if (state.currentMarketId) selectMarket(state.currentMarketId, false);
    });
    document.getElementById('btn-refresh').addEventListener('click', () => {
      renderMarketList();
      if (state.currentMarketId) selectMarket(state.currentMarketId, false);
    });
    document.getElementById('scanButton').addEventListener('click', () => {
      if (isScanning) {
        stopScanning();
      } else {
        startScanning();
      }
    });

    // =======================
    // INITIALIZATION
    // =======================
    // connect WS + translate signals into your alerts
    document.getElementById('status').textContent = 'Connecting‚Ä¶';
    window.__BF_WS_CONNECT__();

    // turn detector signals into your alert cards
    window.__BF_STORE__.onSignal((sig)=>{
      addAlert({
        id: Date.now(),
        name: sig.name,
        track: sig.track,
        patterns: [{ type: sig.type, description: sig.description, confidence: sig.confidence }],
        confidence: sig.confidence,
        timestamp: new Date(),
        race: sig.race
      });
      const ct = document.getElementById('status');
      if (ct) {
        ct.textContent = 'üö® Pattern detected - Scanning Live';
        ct.className = 'status';
      }
      
      // Update pattern count
      const patternsFound = document.getElementById('patternsFound');
      if (patternsFound) patternsFound.textContent = alerts.length;
    });

    // Auto-refresh market list when new data arrives
    let lastMarketUpdate = 0;
    setInterval(() => {
      const store = window.__BF_STORE__;
      if (store && store.markets.size > 0) {
        const now = Date.now();
        if (now - lastMarketUpdate > 2000) { // Update every 2 seconds
          renderMarketList();
          lastMarketUpdate = now;
        }
      }
    }, 2000);

    // Simple alert system (you can enhance this)
    const alerts = [];
    let isScanning = false;

    function addAlert(alert) {
      if (!isScanning) return; // Only add alerts when scanning is active
      alerts.unshift(alert);
      if (alerts.length > 50) alerts.pop(); // keep last 50
      console.log('üö® Signal detected:', alert);
      
      // Pattern alerts are now shown in main view
      
      // Add visual signal
      addVisualSignal(alert);
      
      // Play notification sound (if enabled)
      playNotificationSound(alert.confidence);
      
      // Show desktop notification (if permission granted)
      if (Notification.permission === 'granted') {
        new Notification(`üèá ${alert.patterns[0].type}`, {
          body: `${alert.name} - ${alert.patterns[0].description}`,
          icon: '/favicon.ico',
          tag: alert.id
        });
      }
    }

    function addVisualSignal(alert) {
      const container = document.getElementById('patternAlerts');
      const pattern = alert.patterns[0];
      const confidence = Math.round(alert.confidence * 100);
      
      const signalClass = pattern.type.toLowerCase().replace('_', '-');
      const timeStr = alert.timestamp.toLocaleTimeString();
      
      // Create alerts container if it doesn't exist
      if (!container.innerHTML.includes('Live Pattern Alerts')) {
        container.innerHTML = '<h3 style="margin-bottom: 15px; text-align: center;">üö® Live Pattern Alerts</h3>';
      }
      
      const div = document.createElement('div');
      div.className = `signal-item signal-${signalClass}`;
      div.innerHTML = `
        <div class="signal-header">
          <div style="font-weight: bold;">üèÅ ${alert.race}</div>
          <div class="signal-conf">${confidence}%</div>
        </div>
        <div class="signal-desc"><strong>${alert.name}</strong> - ${pattern.description}</div>
        <div style="margin: 8px 0;">
          <span class="signal-type">${pattern.type.replace('_', ' ')}</span>
        </div>
        <div class="signal-meta">${timeStr}</div>
      `;
      
      container.appendChild(div);
      
      // Keep only last 15 visual signals
      const signals = container.querySelectorAll('.signal-item');
      while (signals.length > 15) {
        signals[0].remove();
      }
    }

    function playNotificationSound(confidence) {
      // Create audio context and play beep based on confidence
      try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        
        // Higher confidence = higher pitch
        osc.frequency.setValueAtTime(300 + (confidence * 400), ctx.currentTime);
        osc.connect(gain);
        gain.connect(ctx.destination);
        
        gain.gain.setValueAtTime(0.1, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
        
        osc.start(ctx.currentTime);
        osc.stop(ctx.currentTime + 0.1);
      } catch (e) {
        // Audio not supported, fail silently
      }
    }

    function startScanning() {
      isScanning = true;
      const btn = document.getElementById('scanButton');
      btn.textContent = '‚èπÔ∏è Stop Scanning';
      btn.classList.add('scanning');
      document.getElementById('status').textContent = 'Scanning Live';
      
      // Request notification permission
      if (Notification.permission === 'default') {
        Notification.requestPermission();
      }
      
      // no timers; signals arrive via WebSocket/store
    }

    function stopScanning() {
      isScanning = false;
      const btn = document.getElementById('scanButton');
      btn.textContent = 'üîç Start Pattern Scanning';
      btn.classList.remove('scanning');
      document.getElementById('status').textContent = 'Ready';
    }

  </script>
</body>
</html>