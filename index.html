<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UK & Ireland Racing - Winner Predictor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0f1c;
            color: #ffffff;
            min-height: 100vh;
        }

        .header {
            background: linear-gradient(135deg, #1a2332 0%, #2d3748 100%);
            padding: 1rem 2rem;
            border-bottom: 2px solid #4a5568;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 1.8rem;
            font-weight: 700;
            color: #00ff88;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff4444;
            transition: all 0.3s ease;
        }

        .status-dot.connected {
            background: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .main-container {
            padding: 2rem;
            max-width: 1400px;
            margin: 0 auto;
        }

        .stats-bar {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: #1a2332;
            border: 1px solid #4a5568;
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: #00ff88;
            margin-bottom: 0.5rem;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #a0a0a0;
        }

        .races-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 1.5rem;
        }

        .race-card {
            background: #1a2332;
            border: 1px solid #4a5568;
            border-radius: 12px;
            overflow: hidden;
            transition: transform 0.2s ease, border-color 0.2s ease;
        }

        .race-card:hover {
            transform: translateY(-2px);
            border-color: #00ff88;
        }

        .race-header {
            background: linear-gradient(135deg, #2d3748 0%, #1a2332 100%);
            padding: 1rem;
            border-bottom: 1px solid #4a5568;
        }

        .race-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #00ff88;
            margin-bottom: 0.5rem;
        }

        .race-info {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            color: #a0a0a0;
        }

        .runners-list {
            padding: 1rem;
        }

        .runner {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            margin: 0.5rem 0;
            background: #0f1419;
            border-radius: 6px;
            border-left: 3px solid transparent;
            transition: all 0.2s ease;
        }

        .runner.predicted-winner {
            border-left-color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
        }

        .runner.strong-pattern {
            border-left-color: #ffaa00;
            background: rgba(255, 170, 0, 0.1);
        }

        .runner-name {
            font-weight: 500;
            color: #ffffff;
        }

        .runner-details {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .odds {
            font-family: monospace;
            font-weight: 600;
            color: #00aaff;
            min-width: 50px;
            text-align: right;
        }

        .confidence {
            background: #00ff88;
            color: #000;
            padding: 0.2rem 0.5rem;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
            min-width: 45px;
            text-align: center;
        }

        .confidence.medium {
            background: #ffaa00;
        }

        .confidence.low {
            background: #666;
            color: #fff;
        }

        .no-data {
            text-align: center;
            padding: 4rem 2rem;
            color: #666;
        }

        .loading {
            text-align: center;
            padding: 4rem 2rem;
            color: #00ff88;
        }

        .loading::after {
            content: '...';
            animation: dots 1.5s infinite;
        }

        @keyframes dots {
            0%, 20% { content: ''; }
            40% { content: '.'; }
            60% { content: '..'; }
            80%, 100% { content: '...'; }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üèÜ UK & Ireland Racing - Winner Predictor</h1>
        <div class="connection-status">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">Connecting...</span>
        </div>
    </div>

    <div class="main-container">
        <div class="stats-bar">
            <div class="stat-card">
                <div class="stat-value" id="totalRaces">0</div>
                <div class="stat-label">Today's Races</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="predictedWinners">0</div>
                <div class="stat-label">Predicted Winners</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="strongPatterns">0</div>
                <div class="stat-label">Strong Patterns</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="avgConfidence">0%</div>
                <div class="stat-label">Avg Confidence</div>
            </div>
        </div>

        <div id="racesContainer" class="races-grid">
            <div class="loading">Loading today's racing data</div>
        </div>
    </div>

    <script>
        class RacingPredictor {
            constructor() {
                this.ws = null;
                this.races = new Map();
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.reconnectDelay = 2000;
                
                this.wsUrls = [
                    'wss://pursuit-partial-venice-thought.trycloudflare.com',
                    'ws://194.164.95.216:10000',
                    'ws://localhost:10000'
                ];
                
                this.connect();
                
                // Update UI every 10 seconds
                setInterval(() => this.updateUI(), 10000);
            }

            connect() {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) return;

                const wsUrl = this.wsUrls[this.reconnectAttempts % this.wsUrls.length];
                console.log(`Connecting to: ${wsUrl}`);
                
                try {
                    this.ws = new WebSocket(wsUrl);
                    this.setupWebSocket();
                } catch (error) {
                    console.error('WebSocket connection error:', error);
                    this.handleReconnect();
                }
            }

            setupWebSocket() {
                this.ws.onopen = () => {
                    console.log('Connected to racing backend');
                    this.updateConnectionStatus(true);
                    this.reconnectAttempts = 0;
                    
                    // Send hello message
                    this.ws.send(JSON.stringify({
                        type: 'hello',
                        client: 'winner-predictor',
                        timestamp: Date.now()
                    }));
                };

                this.ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        this.processMessage(data);
                    } catch (error) {
                        console.error('Message processing error:', error, event.data);
                    }
                };

                this.ws.onclose = () => {
                    console.log('WebSocket connection closed');
                    this.updateConnectionStatus(false);
                    this.handleReconnect();
                };

                this.ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    this.updateConnectionStatus(false);
                };
            }

            processMessage(data) {
                console.log('Processing message:', data.type || data.op);

                // Handle different message formats from backend
                if (data.op === 'mcm' && data.mc) {
                    // Legacy Betfair market change messages
                    this.processMarketChanges(data.mc);
                } else if (data.op === 'connection' && data.connectionId) {
                    // Connection established
                    console.log('Betfair connection established');
                } else if (data.op === 'status') {
                    // Status updates
                    console.log('Status update:', data.statusCode, data.connectionClosed);
                } else if (data.type === 'market_data' && data.markets) {
                    // Backend processed market data
                    this.processBackendMarkets(data.markets);
                } else if (data.type === 'welcome') {
                    // Welcome message
                    console.log('Backend welcome');
                } else {
                    console.log('Unknown message type:', data.type || data.op);
                }

                this.updateUI();
            }

            processMarketChanges(marketChanges) {
                marketChanges.forEach(mc => {
                    if (!mc.marketDefinition) return;

                    const def = mc.marketDefinition;
                    
                    // Filter for UK/Ireland racing WIN markets only
                    const isUKIreland = def.countryCode === 'GB' || def.countryCode === 'IE';
                    const isRacing = def.eventTypeId === '7'; // Horse Racing
                    const isWinMarket = def.name && def.name.includes('Win');
                    
                    if (!isUKIreland || !isRacing || !isWinMarket) return;

                    console.log('Processing UK/IE racing market:', def.venue, def.name);

                    let bestRunner = null;
                    let bestProbability = 0;

                    // Process runner changes
                    if (mc.rc && Array.isArray(mc.rc)) {
                        mc.rc.forEach(rc => {
                            const runner = def.runners.find(r => r.id === rc.id);
                            if (!runner || runner.status !== 'ACTIVE') return;

                            const ltp = rc.ltp;
                            if (!ltp || ltp <= 1) return;

                            // Calculate probability from price
                            const probability = Math.min(95, (1 / ltp) * 100);
                            
                            // Add pattern bonuses
                            let bonus = 0;
                            if (rc.tv && rc.tv > 1000) bonus += 5; // Volume bonus
                            if (rc.batb && rc.batl) {
                                const back = rc.batb[0] && rc.batb[0][0];
                                const lay = rc.batl[0] && rc.batl[0][0];
                                if (back && lay && (lay - back) < 0.02) bonus += 10; // Tight spread
                            }

                            const finalProbability = Math.min(95, probability + bonus);

                            if (finalProbability > bestProbability) {
                                bestProbability = finalProbability;
                                bestRunner = {
                                    name: runner.name,
                                    odds: ltp.toFixed(2),
                                    probability: finalProbability,
                                    patterns: this.detectPatterns(rc)
                                };
                            }
                        });
                    }

                    if (bestRunner) {
                        const raceData = {
                            marketId: mc.id,
                            venue: def.venue || 'Unknown Course',
                            raceName: def.name,
                            startTime: new Date(def.marketTime),
                            runnerCount: def.runners.filter(r => r.status === 'ACTIVE').length,
                            predictedWinner: bestRunner,
                            lastUpdate: Date.now()
                        };

                        this.races.set(mc.id, raceData);
                    }
                });
            }

            processBackendMarkets(markets) {
                if (!Array.isArray(markets)) return;

                console.log(`Processing ${markets.length} backend markets`);

                markets.forEach(market => {
                    if (!market.id) return;

                    // Extract runners and find best prediction
                    const runners = market.runners || [];
                    let bestRunner = null;
                    let bestProbability = 0;

                    runners.forEach(runner => {
                        const ltp = parseFloat(runner.lastPrice || 0);
                        if (ltp <= 1) return;

                        const probability = Math.min(95, (1 / ltp) * 100);
                        
                        if (probability > bestProbability) {
                            bestProbability = probability;
                            bestRunner = {
                                name: runner.name,
                                odds: ltp.toFixed(2),
                                probability: probability,
                                patterns: []
                            };
                        }
                    });

                    if (bestRunner) {
                        const raceData = {
                            marketId: market.id,
                            venue: market.venue || market.name || 'Course',
                            raceName: market.name || 'Race',
                            startTime: new Date(market.startTime || Date.now()),
                            runnerCount: runners.length,
                            predictedWinner: bestRunner,
                            lastUpdate: Date.now()
                        };

                        this.races.set(market.id, raceData);
                    }
                });
            }

            detectPatterns(runnerChange) {
                const patterns = [];
                
                if (runnerChange.tv && runnerChange.tv > 2000) {
                    patterns.push('High Volume');
                }
                
                if (runnerChange.batb && runnerChange.batl) {
                    const back = runnerChange.batb[0] && runnerChange.batb[0][0];
                    const lay = runnerChange.batl[0] && runnerChange.batl[0][0];
                    if (back && lay && (lay - back) < 0.02) {
                        patterns.push('Steam Move');
                    }
                }

                return patterns;
            }

            updateConnectionStatus(connected) {
                const statusDot = document.getElementById('statusDot');
                const statusText = document.getElementById('statusText');
                
                if (connected) {
                    statusDot.classList.add('connected');
                    statusText.textContent = 'Connected';
                } else {
                    statusDot.classList.remove('connected');
                    statusText.textContent = 'Disconnected';
                }
            }

            handleReconnect() {
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    this.reconnectAttempts++;
                    console.log(`Reconnecting in ${this.reconnectDelay}ms (attempt ${this.reconnectAttempts})`);
                    setTimeout(() => this.connect(), this.reconnectDelay);
                    this.reconnectDelay = Math.min(this.reconnectDelay * 1.5, 10000);
                }
            }

            updateUI() {
                const races = Array.from(this.races.values())
                    .filter(race => this.isRecentRace(race))
                    .sort((a, b) => a.startTime - b.startTime);
                
                // Update stats
                document.getElementById('totalRaces').textContent = races.length;
                
                const predictedWinners = races.filter(race => 
                    race.predictedWinner && race.predictedWinner.probability > 30
                );
                document.getElementById('predictedWinners').textContent = predictedWinners.length;
                
                const strongPatterns = races.reduce((count, race) => {
                    return count + (race.predictedWinner?.patterns?.length || 0);
                }, 0);
                document.getElementById('strongPatterns').textContent = strongPatterns;
                
                const avgConfidence = races.length > 0 
                    ? Math.round(races.reduce((sum, race) => 
                        sum + (race.predictedWinner?.probability || 0), 0) / races.length)
                    : 0;
                document.getElementById('avgConfidence').textContent = avgConfidence + '%';
                
                // Render races
                this.renderRaces(races);
            }

            isRecentRace(race) {
                const now = new Date();
                const raceTime = new Date(race.startTime);
                const hoursDiff = (raceTime - now) / (1000 * 60 * 60);
                
                // Show races from 2 hours ago to 6 hours ahead
                return hoursDiff > -2 && hoursDiff < 6;
            }

            renderRaces(races) {
                const container = document.getElementById('racesContainer');
                
                if (races.length === 0) {
                    container.innerHTML = '<div class="no-data">No UK/Ireland racing data available</div>';
                    return;
                }

                const html = races.map(race => this.renderRaceCard(race)).join('');
                container.innerHTML = html;
            }

            renderRaceCard(race) {
                const startTime = race.startTime.toLocaleTimeString('en-GB', {
                    hour: '2-digit',
                    minute: '2-digit'
                });

                const now = new Date();
                const minutesToRace = Math.max(0, Math.round((race.startTime - now) / (1000 * 60)));
                
                const winner = race.predictedWinner;
                const confidenceClass = winner.probability > 70 ? 'high' : 
                                      winner.probability > 40 ? 'medium' : 'low';

                const patterns = winner.patterns && winner.patterns.length > 0 
                    ? winner.patterns.join(', ') 
                    : 'Standard Analysis';

                return `
                    <div class="race-card">
                        <div class="race-header">
                            <div class="race-title">${race.venue}</div>
                            <div class="race-info">
                                <span>${startTime}</span>
                                <span>${minutesToRace}m to go</span>
                            </div>
                        </div>
                        <div class="runners-list">
                            <div class="runner predicted-winner">
                                <div>
                                    <div class="runner-name">${winner.name}</div>
                                    <div style="font-size: 0.8rem; color: #a0a0a0;">${patterns}</div>
                                </div>
                                <div class="runner-details">
                                    <div class="odds">${winner.odds}</div>
                                    <div class="confidence ${confidenceClass}">${Math.round(winner.probability)}%</div>
                                </div>
                            </div>
                            <div style="margin-top: 0.5rem; font-size: 0.8rem; color: #a0a0a0; text-align: center;">
                                ${race.runnerCount} runners
                            </div>
                        </div>
                    </div>
                `;
            }
        }

        // Initialize the racing predictor
        document.addEventListener('DOMContentLoaded', () => {
            new RacingPredictor();
        });
    </script>
</body>
</html>